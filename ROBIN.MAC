	.TITLE	ROBIN
	.MCALL	.SETTOP, .EXIT, .LOOKUP, .READW, .CLOSE

;------------------------------------------------------------------------------

.MACRO	PUSH	RR
	MOV	RR,-(SP)
.ENDM
.MACRO	POP	RR
	MOV	(SP)+,RR
.ENDM

;------------------------------------------------------------------------------

SCREEN = 100000			; Начало экрана
SCRE80 = SCREEN+<80.*80.>	; 80.-я строка экрана, где начинается картинка
SSCREE = SCREEN+40.		; Начало теневого экрана
SSCR80 = SCRE80+40.		; 80.-я строка теневого экрана

;------------------------------------------------------------------------------

	.ASECT
	.=001000
START::
	CLR	@#177560
	MOV	#1000, SP		; Ставим стек
; Определяем верхнюю границу памяти
	.SETTOP	#117776
	CMP	#117776, R0
	BHIS	1$
	MOV	#MEMERR, R1
	JMP	FERROR
1$:
; Открываем файл данных
	.LOOKUP	#FAREA, #0, #FSPEC	; Открываем файл
	BCC	10$
	MOV	#FERR, R1
	JMP	FERROR
10$:
; Отправить программу в ПП
	CALL	PPLOAD			; Установить программу в памяти ПП
; Ставим прерывание таймера
	MOV	#200, @#000102
	MOV	#TMEINT, @#000100

; Сюда возвращаемся после завершения игры
TITLE:
; Очистить экран и задать режим
	MOV	#GAMESC, R1		; Строка для подготовки игрового экрана
	CALL	PRINT
	CALL	PRDOT			; .
; Загрузка заголовочного экрана
	CLR	IOBLK			; Номер блока = 0
	MOV	#<<TITLZS+1>/2>, WCNT	; Сколько слов прочитать
	MOV	#AREA, R5
	.READW	R5, #0			; Читаем данные с диска
	BCC	30$
	MOV	#FERR, R1
	JMP	FERROR
30$:	CALL	PRDOT			; ..
; Распаковать заголовочный экран на адреса 052400-120000, занимает 19200. = 045400 байт
	MOV	#LBEGIN, R1
	MOV	#052400, R2
	CALL	UNLZSA
	CALL	PRDOT			; ...
; Показать заголовочный экран через вызов процедуры в ПП
	MOV	#PPSTART, R1		; Подпрограмма для выполнения на ПП
	CALL	PPRUN			; Запускаем на ПП
	CALL	PAUSE
; Показ главного меню
	MOV	#MENUSC, R1
	CALL	PRINT
40$:	CALL	WTKEY
	CMP	#060, R0		; '0' ?
	BEQ	FINISH
	CMP	#061, R0		; '1' ?
	BNE	40$
; Начало игры
STARTG:
; Очистка переменных игры
	MOV	#IBEGIN, R0
	MOV	#<IEND-IBEGIN>/2, R1
10$:	CLR	(R0)+
	SOB	R1, 10$
; Выводим начальный текст
	MOV	#TEXTPR, R1
	CALL	PRINT
	CALL	WTKEY
; Очистить экран
	MOV	#GAMESC, R1
	CALL	PRINT
	CALL	PAUSE
; Загрузить уровень 1
	MOV	#LEVELS, R0
	JMP	LOALEV
; Обычное завершение программы
FINISH:
	MOV	#EXITSC, R1		; Строка очистки экрана перед выходом
; Точка входа: напечатать ошибку и завершиться
FERROR:	CALL	PRINT
	.CLOSE	#0			; Закрываем файл
	CALL	PPDONE			; Освободить память в ПП
	.EXIT

; Процедура загрузки уровня; R0 = описатель уровня в таблице LEVELS
LOALEV:	CALL	PRDOT			; .
; Загрузка сжатого экрана
	MOV	(R0)+, IOBLK		; Номер блока
	MOV	(R0)+, WCNT		; Сколько слов прочитать
	PUSH	R0
	MOV	#AREA, R5
	.READW	R5, #0
	BCC	10$
	MOV	#FERR, R1
	JMP	FERROR
10$:	CALL	PRDOT			; ..
; Распаковать экран на адреса 052400-120000, занимает 19200. = 045400 байт
	MOV	#LBEGIN, R1
	MOV	#052400, R2
	CALL	UNLZSA
; Показать экран через вызов процедуры в ПП
	MOV	#PPSTART, R1		; Подпрограмма: скопировать экран из ОЗУ ЦП
	CALL	PPRUN			; Запускаем на ПП
	MOV	#PPSCOP, R1		; Подпрограмма: скопировать на теневой экран
	CALL	PPRUN			; Запускаем на ПП
	CALL	PAUSE
	CALL	PRDOT			; ...
; Загрузить сжатые вставки
	POP	R0
	MOV	(R0)+, IOBLK		; Номер блока
	MOV	(R0)+, WCNT		; Сколько слов прочитать
	PUSH	R0
	MOV	#AREA, R5
	.READW	R5, #0
	BCC	20$
	MOV	#FERR, R1
	JMP	FERROR
20$:
; Распаковать сжатые вставки
	MOV	#LBEGIN, R1
	MOV	#052400, R2
	CALL	UNLZSA
; Загрузить код + текст
	POP	R0
	MOV	(R0)+, IOBLK		; Номер блока
	MOV	(R0)+, WCNT		; Сколько слов прочитать
	MOV	#AREA, R5
	.READW	R5, #0
	BCC	30$
	MOV	#FERR, R1
	JMP	FERROR
30$:
	;CALL	PRDOT			; ....
; Приготовить вставки под экраном
	MOV	#PPEXTP, R1		; Подпрограмма: приготовить вставки
	CALL	PPRUN			; Запускаем на ПП
	CALL	PAUSE
; Переход на код уровня
	JMP	LBEGIN

; Игра окончена, Робинзон умер
GAMEOVER:
;TODO: Пауза, стираем экран, пауза
	JMP	TITLE

FAREA:	.BLKW	3
FSPEC:	.RAD50	/DK ROBIN DAT/	; Имя файла с данными
AREA:	.WORD	0
IOBLK:	.WORD	0		; С какого блока читать
	.WORD	LBEGIN		; Адрес куда читать данные
WCNT:	.WORD	256.		; Сколько слов читать
	.WORD	0

MEMERR:	.ASCIZ	/Недостаточно памяти/
FERR:	.ASCIZ	/Ошибка чтения ROBIN.DAT/
GAMESC:	; Строка подготовки игрового экрана
	.BYTE	033,246,62	; Формат экрана 40x24
	;.BYTE	033,246,061	;DEBUG Формат экрана 80x24
	.BYTE	033,240,67	; Цвет символа
	.BYTE	033,241,60	; Цвет знакоместа 0
	.BYTE	033,242,60	; Цвет фона 0
	.BYTE	14		; Clear screen
	.BYTE	0
EXITSC:	; Строка очистки экрана перед выходом
	.BYTE	033,246,061	; Формат экрана 80x24
	.BYTE	033,240,67	; Цвет символа
	.BYTE	033,241,61	; Цвет знакоместа 1
	.BYTE	033,242,61	; Цвет фона 1
	.BYTE	14		; Очистить экран
	.BYTE	0
MENUSC: ; Текст меню
	.BYTE	033,240,66	; Цвет символа
	.BYTE	033,131,40,40	; Курсор в позицию
	.ASCII	/РОБИНЗОН КРУЗО/<25>
	.ASCII	/Coktel Vision 1987/<25><12>
	.ASCII	/версия для УКНЦ:/<25>/NZeemin/<25>
.INCLUDE /VERSIO.MAC/
	.BYTE	033,240,67	; Цвет символа
	.BYTE	033,131,42,66	; Курсор в позицию
	.ASCII	/1. НОВАЯ ИГРА/
	.BYTE	033,131,43,66	; Курсор в позицию
	.ASCII	/0. ВЫХОД/
	.BYTE	033,131,44,66	; Курсор в позицию
	.BYTE	0

; Текст прелюдии перед началом игры
TEXTPR:	.BYTE	14		; Очистить экран
	.BYTE	033,131,41,51	; Курсор в позицию
	.BYTE	033,240,63	; Цвет символа
	.ASCII	/30 СЕНТЯБРЯ 1659 ГОДА/<25><12><12>
	.BYTE	033,240,67	; Цвет символа
	.ASCII	/... "Мы увидели яростную волну, похожую/<25><12>
	.ASCII	/ на гору... она опрокинула нашу шлюпку/<25><12>
	.ASCII	/ и отделила нас друг от друга, а также/<25><12>
	.ASCII	/ от лодки. В одно мгновение мы все были/<25><12>
	.ASCII	/ поглощены." .../<25><12>
	.ASCII	/ "Но я пришел в себя и смог, наконец,/<25><12>
	.ASCII	/ добраться до берега."/
	.BYTE	033,131,62,106	; Курсор в позицию
	.BYTE	224		; символ "перевод строки"
	.BYTE	0
; Очистка области сообщений (7 строк)
CLMSG:
	.BYTE	033,131,40,40		; Курсор в позицию 0,0
	.BYTE	013,012			; Очистка конца строки, шаг вниз
	.BYTE	013,012
	.BYTE	013,012
	.BYTE	013,012
	.BYTE	013,012
	.BYTE	013,012
	.BYTE	013			; Очистка конца строки
	.BYTE	033,131,40,40		; Курсор в позицию 0,0
	.BYTE	0
; Ставим курсор справа внизу блока сообщений, показывая, что мы ждём нажатия
WTKEYT:
	.BYTE	033,131,46,106		; Курсор в позицию
	.BYTE	224			; символ "перевод строки"
	.BYTE	0
; Ставим курсор слева внизу блока сообщений, показывая, что мы ждём выбора из вариантов
WTSELT:
	.BYTE	033,131,46,41		; Курсор в позицию
	.BYTE	013			; Очистка конца строки
	.BYTE	0
	.EVEN

; Прерывание таймера ЦП, вызывается 50 раз в секунду
TMEINT:
	INC	TIMETK
	RTI
TIMETK:	.WORD	0		; Счётчик тиков таймера

; Ожидание по таймеру; R0 = сколько тиков ждать
WTTIME:
	CLR	TIMETK
10$:	NOP
	NOP
	NOP
	CMP	R0, TIMETK
	BGE	10$
	RETURN

; Таблица уровней, используется при загрузке уровня
.INCLUDE /LEVELS.MAC/

; Подпрограмма загрузки программы в память ПП
PPLOAD:
	MOVB	#1, PPBCMD		; Команда "Выделить память"
	CALL	PPSEND			; Отправляем блок параметров
;TODO: Анализировать код ошибки по адресу PPBLCK
	MOVB	#20, PPBCMD		; Команда "Запись"
	MOV	#PPSTART, PPBACP	; Адрес блока в ОЗУ ЦП
	CALL	PPSEND			; Отправляем блок параметров
	MOV	PPBAPP, PPBAPS		; Сохраняем адрес где начинаются подпрограммы
	RETURN
; Подпрограмма освобождения памяти ПП
PPDONE:
	MOVB	#2, PPBCMD		; Команда "Освободить память"
	MOV	#PPSTART, PPBACP	; Адрес блока в ОЗУ ЦП
	CALL	PPSEND			; Отправляем блок параметров
	RETURN
; Подпрограмма запуска программы в памяти ПП
; R1 = адрес подпрограммы
PPRUN:
	MOV	#177777, PPFINF		; Признак завершения
	MOVB	#30, PPBCMD		; Команда "Запуск"
	SUB	#PPSTART, R1
	ADD	PPBAPS, R1
	MOV	R1, PPBAPP		; Адрес блока в ОЗУ ЦП
	CALL	PPSEND			; Отправляем блок параметров
;TODO: Анализировать код ошибки по адресу PPBLCK
10$:	TST	PPFINF
	BMI	10$			; Ждём завершения
	RETURN

PPBAPS: .WORD	0		; Адрес в ОЗУ ПП где начинаются подпрограммы
; Массив параметров для управлением программой в памяти ПП
PPBLCK:	.BYTE	0		; В этом байте будет содержаться код ошибки или 0
PPBCMD:	.BYTE	0		; Команда (01-ВЫДЕЛИТЬ ПАМЯТЬ, 02-ОСВОБОДИТЬ ПАМЯТЬ 10-ЧТЕНИЕ, 20-ЗАПИСЬ, 30-ПУСК)
	.WORD	32		; Устройство -- периферийный процессор
PPBAPP:	.WORD	0		; Адрес ОЗУ ПП
PPBACP:	.WORD	0		; Адрес ОЗУ ЦП
	.WORD	<PPEND-PPSTART>/2	; Длина программы в словах
PPBADR:	.WORD	PPBLCK		; Слово всегда содержит начальный адрес массива параметров
	.WORD	401		; Стоповый элемент (используется при передаче)

; Подпрограмма передачи по каналу К2 массива параметров в ПП
PPSEND:	MOV	#PPBADR, R0
	MOV	#5, R1
	BR	1$
2$:	MOVB	(R0)+, @#176676
1$:	TSTB	@#176674
	BPL	1$
	SOB	R1, 2$
	RETURN

; Подпрограмма копирования вставки с теневого экрана на обычный экран через ПП
; R0 = номер вставки
; R1 = X/Y куда выводить на экране
PPREX:
; Найти элемент в таблице вставок, взять там X/Y и W/H
	ASL	R0
	ASL	R0			; R0 = номер вставки * 4
	ADD	#ESTRAT, R0		; + адрес таблицы вставок
	MOV	R1, R3
	MOV	(R0)+, R1		; X/Y вставки
	MOV	(R0), R2		; R2 = W/H вставки
; Переводим координаты в адреса на экране
	CALL	XY2SS			; X/Y -> адрес на теневом экране
	MOV	R1, R0			; R0 = адрес откуда копировать
	MOV	R3, R1
	CALL	XY2SCR			; X/Y -> адрес на обычном экране
;	JMP	PPREX2
;
; Подпрограмма копирования фрагмента с теневого экрана на обычный экран через ПП
; R0 = адрес откуда копировать
; R1 = адрес куда копировать
; R2 = W/H
PPREX2:
	MOV	R0, PPEXCH		; адрес откуда
	MOV	R1, <PPEXCH+2>		; адрес куда
	MOV	R2, <PPEXCH+4>		; W/H
	MOV	#PPEXT2, R1
	JMP	PPRUN

; Перевод из X/Y обычного экрана в адрес; Y считаем от 80.-й строки
; R1 = X/Y
XY2SCR:	PUSH	R0
	MOV	R1, R0
	BIC	#177700, R0		; теперь X в R0, оставляем 0..63
	SWAB	R1			; теперь Y в младшей части
	BIC	#177700, R1		; оставляем 0..63
	MUL	#<8.*80.>, R1
	ADD	R0, R1
	ADD	#SCRE80, R1		; + адрес на экране, начало картинки
	POP	R0
	RETURN

; Перевод из X/Y теневого экрана в адрес; Y считаем от самого верха
; R1 = X/Y
XY2SS:	PUSH	R0
	MOV	R1, R0
	BIC	#177700, R0		; теперь X в R0, оставляем 0..63
	SWAB	R1			; теперь Y в младшей части
	BIC	#177700, R1		; оставляем 0..63
	MUL	#<8.*80.>, R1
	ADD	R0, R1
	ADD	#SSCREE, R1		; + начало теневого экрана
	POP	R0
	RETURN

; Анимирование, поочерёдный вывод на экран двух вставок
; R0 = номер вставки, R1 = номер второй вставки
; R2 = X/Y куда выводить на экране
; R3 = задержка между выводом вставок, тиков таймера
ANIMAT:
	MOV	R3, ANIDLY
	PUSH	R2
	PUSH	R1
; По таблице вставок получить X/Y для первой вставки
	ASL	R0
	ASL	R0			; R0 = номер вставки * 4
	ADD	#ESTRAT, R0		; + адрес таблицы вставок
	MOV	(R0)+, R1		; получили X/Y первой вставки
	MOV	(R0), ANIWH		; получили W/H
; Перевести X/Y в адрес на теневом экране
	CALL	XY2SS			; R1 = адрес первой вставки
	MOV	R1, ANIXY1
; По таблице вставок получить X/Y и W/H для второй вставки
	POP	R0			; R0 = номер второй вставки
	ASL	R0
	ASL	R0			; R0 = номер вставки * 4
	ADD	#ESTRAT, R0		; + адрес таблицы вставок
	MOV	(R0), R1		; получили X/Y второй вставки
; Перевести X/Y в адрес на теневом экране
	CALL	XY2SS			; R1 = адрес второй вставки
	MOV	R1, ANIXY2
; Перевести X/Y в адрес на основном экране
	POP	R1			; R1 = X/Y куда выводить
	CALL	XY2SCR			; R1 = адрес куда
	MOV	R1, ANISCR
; Очистим буфер клавиш
5$:	CALL	GETKEY
	BNE	5$
10$:					; Начало цикла анимации
; Вывести первую вставку
	MOV	ANIXY1, R0		; откуда
	MOV	ANISCR, R1		; куда
	MOV	ANIWH, R2		; W/H
	CALL	PPREX2			; Копируем первую вставку
; Пауза с проверкой клавиатуры
	CLR	TIMETK
	MOV	ANIDLY, R3
20$:	CALL	GETKEY			; Проверка нажатия
	BNE	100$			; нажато => выходим
	CMP	R3, TIMETK
	BGE	20$
; Вывести вторую вставку
	MOV	ANIXY2, R0		; откуда
	MOV	ANISCR, R1		; куда
	MOV	ANIWH, R2		; W/H
	CALL	PPREX2			; Копируем вторую вставку
; Пауза с проверкой клавиатуры
	CLR	TIMETK
	MOV	ANIDLY, R3
30$:	CALL	GETKEY			; Проверка нажатия
	BNE	100$			; нажато => выходим
	CMP	R3, TIMETK
	BGE	30$
	BR	10$			; продолжаем цикл анимации
100$:	RETURN
ANIXY1:	.WORD	0	; Адрес вставки 1
ANIXY2:	.WORD	0	; Адрес вставки 2
ANISCR:	.WORD	0	; Адрес куда выводить на основном экране
ANIWH:	.WORD	0	; W/H
ANIDLY:	.WORD	0	; Задержка

;------------------------------------------------------------------------------

; Признак завершения работы процедуры ПП
PPFINF:	.WORD	0
; Область для передачи параметров при вызове процедур ПП
PPEXCH:	.BLKW	3

;------------------------------------------------------------------------------
; Блок от PPSTART до PPEND предназначен для отправки в память ПП
; код должен быть перемещаемым!

; Копируем графику из памяти ЦП на экран, все три плана, 320x160, 19200 байт
PPSTART:
	MOV	#025200, R4		; Адрес откуда берём данные = 052400 в памяти ЦП
	MOV	#SCRE80, R3		; адрес на экране, начало картинки
	MOV	#40., R2		; количество столбцов
20$:	PUSH	R2
	PUSH	R3
	MOV	#80., R5		; количество строк / 2
10$:
	MOV	R4, @#177010
	MOV	@#177014, R0		; читаем из планов 1/2 - 1 слово
	INC	R4
	MOV	R4, @#177010
	MOV	@#177014, R1		; читаем из планов 1/2 - 2 слово
	INC	R4
	MOV	R4, @#177010
	MOV	@#177014, R2		; читаем из планов 1/2 - 3 слово
	INC	R4

	SWAB	R1
	PUSH	R1
	SWAB	R0
	BIC	#377, R1
	BISB	R0, R1
	SWAB	R0

	MOV	R3, @#177010
	MOV	R0, @#177012		; записываем в план 0
	MOV	R1, @#177014		; записываем в планы 1/2
	ADD	#80., R3		; к следующей строке

	POP	R1

	MOV	R3, @#177010
	MOV	R1, @#177012		; записываем в план 0
	MOV	R2, @#177014		; записываем в планы 1/2
	ADD	#80., R3		; к следующей строке

	SOB	R5, 10$
	POP	R3
	INC	R3			; к следующей колонке
	POP	R2
	SOB	R2, 20$
	BR	PPFIN			; Ставим признак завершения

; Копируем с экрана картинку 320x160 в теневую область "под экраном"
PPSCOP:
	MOV	#SCRE80, R3		; адрес на экране, начало картинки
	MOV	#SSCR80, R4		; адрес 80.-й строки теневого экрана
	MOV	#160., R5		; количество строк
30$:	MOV	#40., R2		; количество столбцов / слов для копирования
40$:	MOV	R3, @#177010
	MOV	@#177012, R0		; читаем из плана 0
	MOV	@#177014, R1		; читаем из планов 1 / 2
	MOV	R4, @#177010
	MOV	R0, @#177012		; пишем в план 0
	MOV	R1, @#177014		; пишем в план 1 / 2
	INC	R3
	INC	R4
	SOB	R2, 40$
	MOV	R4, R3			; начало следующей строки экрана
	ADD	#40., R4		; начало следующей строки теневого экрана
	SOB	R5, 30$			; продолжение цикла по строкам
	BR	PPFIN			; Ставим признак завершения

; Подготовка вставок на теневом экране
; 052400 = адрес ОЗУ ЦП где лежат распакованные вставки
; <LBEGIN+2> = адрес ОЗУ ЦП таблицы вставок ESTRAT для текущего уровня
PPEXTP:
	MOV	#025200, R4		; Адрес где лежат вставки = 052400 в памяти ЦП
	MOV	#<<LBEGIN+2>/2>, R3	; Адрес таблицы вставок в памяти ЦП
10$:
	MOV	R3, @#177010
	MOV	@#177014, R1		; читаем X/Y из планов 1 / 2 - ОЗУ ЦП
	CMP	#177777, R1
	BEQ	PPFIN			; если там 177777, то это конец таблицы
; Переводим X/Y в адрес на экране: Y * 8. * 80. + X + начало экрана
	MOV	R1, R0
	BIC	#177700, R0		; теперь X в R0
	SWAB	R1			; теперь Y в младшей части
	BIC	#177700, R1		; оставляем младшую часть
	MUL	#<8.*80.>, R1
	ADD	R0, R1
	ADD	#SSCREE, R1		; + начало теневого экрана
; Переходим к ширине/высоте
	INC	R3
	MOV	R3, @#177010
	MOV	@#177014, R0		; читаем W/H из планов 1 / 2 - ОЗУ ЦП
; Обработаем одну вставку
	PUSH	R3
	CALL	PPEXT1
	POP	R3
	INC	R3			; переходим к следующей строке таблицы вставок
	BR 	10$			; продолжаем цикл
;
; Ставим признак завершения; вызывается в конце каждой процедуры в этом блоке
PPFIN:	MOV	#<PPFINF/2>, @#177010
	CLR	@#177014		; записываем в планы 1/2
	RETURN

; Подпрограмма: Перенести вставку на теневой экран
; R1 = адрес на экране; R0 = W/H вставки; R4 = графика вставки
PPEXT1:
	MOV	R1, R3			; R3 = адрес на экране
10$:	PUSH	R0			; Цикл по столбцам
	MOV	R0, R5
	SWAB	R5
	BIC	#177400, R5		; R5 = H
	ASL	R5			; R5 = H * 2
	ASL	R5			; R5 = H * 4
	PUSH	R3
20$:					; Цикл по строкам
	MOV	R4, @#177010
	MOV	@#177014, R0		; читаем из планов 1/2 - 1 слово
	INC	R4
	MOV	R4, @#177010
	MOV	@#177014, R1		; читаем из планов 1/2 - 2 слово
	INC	R4
	MOV	R4, @#177010
	MOV	@#177014, R2		; читаем из планов 1/2 - 3 слово
	INC	R4
	SWAB	R1
	PUSH	R1
	SWAB	R0
	BIC	#377, R1
	BISB	R0, R1
	SWAB	R0
	MOV	R3, @#177010
	MOV	R0, @#177012		; записываем в план 0
	MOV	R1, @#177014		; записываем в планы 1/2
	ADD	#80., R3		; к следующей строке
	POP	R1
	MOV	R3, @#177010
	MOV	R1, @#177012		; записываем в план 0
	MOV	R2, @#177014		; записываем в планы 1/2
	ADD	#80., R3		; к следующей строке
;
	SOB	R5, 20$
	POP	R3			; восстанавливаем адрес на экране
	INC	R3			; следующий столбец
	POP	R0
	DECB	R0
	BNE	10$
	BR	PPFIN			; Ставим признак завершения

; Копировать фрагмент из теневого экрана на экран
; параметры передаются через блок PPEXCH:
; (PPEXCH+0) = адрес откуда копировать
; (PPEXCH+2) = адрес куда копировать
; (PPEXCH+4) = W/H
PPEXT2:
; Получаем параметры из памяти ЦП
	MOV	#<PPEXCH/2>, R5
	MOV	R5, @#177010
	MOV	@#177014, R4		; адрес откуда
	INC	R5
	MOV	R5, @#177010
	MOV	@#177014, R3		; адрес куда
	INC	R5
	MOV	R5, @#177010
	MOV	@#177014, R5		; W/H
; Копируем фрагмент
10$:					; Цикл по столбцам
	PUSH	R5
	SWAB	R5
	BIC	#177400, R5		; R5 = H
	ASL	R5			; R5 = H * 2
	ASL	R5			; R5 = H * 4
	PUSH	R3
	PUSH	R4
20$:					; Цикл по строкам
	MOV	R4, @#177010
	MOV	@#177014, R1		; читаем из планов 1/2
	MOV	@#177012, R0		; читаем из плана 0
	MOV	R3, @#177010
	MOV	R0, @#177012		; пишем в план 0
	MOV	R1, @#177014		; пишем в план 1 / 2
	ADD	#80., R4		; к следующей строке
	ADD	#80., R3		; к следующей строке
	MOV	R4, @#177010
	MOV	@#177014, R1		; читаем из планов 1/2
	MOV	@#177012, R0		; читаем из плана 0
	MOV	R3, @#177010
	MOV	R0, @#177012		; пишем в план 0
	MOV	R1, @#177014		; пишем в план 1 / 2
	ADD	#80., R4		; к следующей строке
	ADD	#80., R3		; к следующей строке
;
	SOB	R5, 20$
	POP	R4
	POP	R3			; восстанавливаем адрес на экране
	INC	R4			; следующий столбец
	INC	R3			; следующий столбец
	POP	R5
	DECB	R5			; уменьшаем W
	BNE	10$
	BR	PPFIN			; Ставим признак завершения

PPEND:	; Точка завершения всех процедур ПП

;------------------------------------------------------------------------------

; Подпрограмма: Печать строки: R1 = адрес строки, строка завершается 0; портит R0
; После завершения R1 указывает на байт следующий за 0
PRINT:
10$:	MOVB	(R1)+, R0		; Конец строки?
	BEQ	RETN			; да => выходим
20$:	TSTB	@#177564		; Источник канала 0 готов?
	BPL	20$			; нет => ждём
	MOV	R0, @#177566		; передаём символ в канал 0
	BR	10$

; Подпрограмма: Вывести символ точки
PRDOT:
20$:	TSTB	@#177564		; Источник канала 0 готов?
	BPL	20$			; нет => ждём
	MOV	#56, @#177566		; передаём символ '.' в канал 0
	BR	RETN

; Подпрограмма: Ожидание символа с клавиатуры: R0 = полученный символ
WTKEY:	TSTB	@#177560
	BPL	WTKEY
	CLR	R0
	MOVB	@#177562, R0		; символ в R0
	CMPB	R0, #33
	BNE	RETN
ESCKEY:	TSTB	@#177560
	BPL	ESCKEY
	MOVB	@#177562, R0		; символ в R0
	BIS	#15400,R0		; #33 в верхний байт
RETN:	RETURN
; Подпрограмма: Получение символа с клавиатуры: флаг Z=0 = есть символ, R0 = полученный символ
GETKEY:	TSTB	@#177560		; есть символ?
	BPL	10$			; нет символа => выходим
	MOVB	@#177562, R0		; символ в R0
	CMPB	R0, #33			; Esc ?
	BEQ	ESCKEY
	RETURN
10$:	CLR	R0			; возвращаем пустой код клавиши и Z=1
	RETURN

; Подпрограмма: Ожидание ввода цифры '1'..N;
; R1 = N в виде символа, например, #062 для '2'
; Результат: R0 = символ цифры '1'..N
WTKEYN:	CALL	WTKEY
	CMP	#061, R0		; '1'
	BHI	WTKEYN
	CMP	R1, R0
	BLT	WTKEYN
	RETURN

;Подпрограмма: пауза после очистки экрана чтобы ПП закончил работу
PAUSE:	; Pause to let PPU finish the previous commands
	MOV	#177777, R5
PAUSE0:	NOP
	SOB	R5, PAUSE0
	RETURN

;------------------------------------------------------------------------------

; https://github.com/purplesyringa/lzsa3
; Optimized LZSA3 decompressor for PDP-11 by Manwe and Ivanq. Thanks to Ivan Gorodetsky
; Usage: MOV #src_adr,R1 / MOV #dst_adr,R2 / CALL UNLZSA
UNLZSA::
	CLR R5				; no nibbles sign
10$:	MOVB (R1)+,R3			; read token
;Liter:
20$:	MOV R3,R0
	BIC #177774,R0			; get 2 bits
	BEQ 30$
	CMP R0,#3			; literals length
	BNE 25$
	CALL 110$
25$:	MOVB (R1)+,(R2)+		; literals length in R0
	SOB R0,25$
;Decode:
30$:	MOV R3,-(SP)
	ROLB R3				; get 2 bits
	ROL R0
	ROLB R3
	ROL R0
	ASL R0
	ADD R0,PC			; run subroutine
	BR 90$
	BR 70$
	BR 80$
;o5bit:
40$:	CALL 100$			; get nibble in R0
	ROLB R3
	ROL R0
	INC R0
;Save:
50$:	MOV R0,R4			; save offset for future
;Match:
55$:	MOV (SP)+,R0
	ASR R0
	ASR R0
	BIC #177770,R0			; get 3 bits
	CMP R0,#7
	BNE 60$
	CALL 110$
	TSTB R0				; match length
	BEQ 120$
;Clone:
60$:	MOV R2,R3
	SUB R4,R3
	MOVB (R3)+,(R2)+
	INC R0
61$:	MOVB (R3)+,(R2)+
	SOB R0,61$
	BR 10$
;o9bit:
70$:	CLR R0
	BISB (R1)+,R0
	ROLB R3
	ROL R0
	INC R0
	BR 50$
;o13bit:
80$:	CALL 100$ 			; get nibble in R0
	ROLB R3
	ROL R0
	SWAB R0
	BISB (R1)+,R0			; 8 bits
	ADD #513.,R0
	BR 50$
;oOther:
90$:	ROLB R3
	BCS 55$
	BISB (R1)+,R0			; read 16 bits
	SWAB R0
	BISB (R1)+,R0
	BR 50$
;Nibble:
100$:	COM R5
	BMI 101$
	MOV R5,R0
	CLR R5
	BR 102$
101$:	BICB (R1)+,R5			; read 2 nibbles
	MOV R5,R0
	ASR R0
	ASR R0
	ASR R0
	ASR R0
102$:	BIC #177760,R0			; leave 4 low bits
	RETURN
;Extend:
110$:	MOV R0,-(SP)			; save original value
	CALL 100$ 			; get nibble in R0
	BNE 112$
	BISB (R1)+,R0
	BNE 111$
	; unnecessary for short files
	BISB (R1)+,R0			; read high byte
	SWAB R0
	BISB (R1)+,R0			; read low byte
	TST (SP)+			; skip saved R0
	RETURN
111$:	ADD #15.,R0
112$:	DEC R0
	ADD (SP)+,R0			; add original value
;Exit:
120$:	RETURN

;------------------------------------------------------------------------------

; Вспомогательная процедура для макроса .WTSEL, переход по выбранному варианту
JMPNUM:
	SUB	#061, R0		; 0..N-1
	ASL	R0			; *2
	ADD	(SP), R0
	MOV	(R0), R0
	JMP	(R0)

; Выбор R0 вариантов из R1
SELNM:	CLR	SELNMF			; Очищаем выбранные биты
	MOV	R0, SELNMN
	MOV	R0, R4			; R4 = сколько нужно выбрать
	ADD	#060, R1
10$:	CALL	WTKEYN			; ограничивает ввод цифрами от 1 до R1
	PUSH	R1
; Выставляем/снимаем бит в SELNMF
	SUB	#060, R0		; оставляем номер бита 1..M
	MOV	#1, R5
12$:	ASL	R5
	SOB	R0, 12$
	XOR	R5, SELNMF		; ставим/снимаем бит
; Формируем буфер SELNMB
	MOV	#SELNMB, R3		; R3 = адрес в буфере SELNMB
	MOV	#2, R5			; бит #1
	MOV	#061, R0		; номер бита как символ '1'
	CLR	R2			; сколько выбрано
15$:	BIT	R5, SELNMF		; проверяем бит
	BEQ	20$
	MOVB	R0, (R3)+
	INC	R2			; выбрано +1
20$:	ASL	R5
	INC	R0
	CMP	#072, R0		; символ после '9'
	BNE	15$
	CLRB	(R3)			; ноль в конце буфера
; Выводим буфер на экран
	MOV	#WTSELT, R1
	CALL	PRINT			; ставим курсор
	MOV	#SELNMB, R1
	CALL	PRINT			; выводим буфер
; Продолжаем цикл
	POP	R1
	CMP	SELNMN, R2		; выбрали всё что нужно?
	BNE	10$
	MOV	SELNMF, R0		; возвращаемое значение
	RETURN
SELNMN:	.WORD	0			; сколько нужно выбрать (N)
SELNMF:	.WORD	0			; выбранные биты
SELNMB:	.BYTE	10.			; буфер символов для SELNM
	.EVEN

;------------------------------------------------------------------------------
; Переменные игры (inventory)
IBEGIN:
IGUN:	.WORD	0			; Есть оружие
IFOOD:	.WORD	0			; Есть еда
IMONEY:	.WORD	0			; Есть деньги
ITOOL:	.WORD	0			; Есть рычаг
IEND:

;------------------------------------------------------------------------------
; Макросы для использования в коде уровней

; Печать текста
.MACRO	.PRINT	T
	MOV	T, R1
	CALL	PRINT
.ENDM

; Очистка области сообщений
.MACRO	.CLMSG
	MOV	#CLMSG, R1
	CALL	PRINT
.ENDM

; Очистка области сообщений и вывод сообщения
.MACRO	.PRMSG	T
	MOV	#CLMSG, R1
	CALL	PRINT
	MOV	T, R1
	CALL	PRINT
.ENDM

; Показываем что ждём нажатия клавиши и ожидаем нажатия
.MACRO	.WTKEY
	MOV	#WTKEYT, R1
	CALL	PRINT
	CALL	WTKEY
.ENDM

; Показываем что ждём выбора из предложенных вариантов;
; параметр K = код символа-цифры для максимального варианта, например, #067 для '7';
; после макроса с помощью .WORD должны быть перечислены адреса перехода
.MACRO	.WTSEL	K
	MOV	#WTSELT, R1
	CALL	PRINT
	MOV	K, R1
	CALL	WTKEYN			; ограничивает ввод цифрами от 1 до K
	CALL	JMPNUM
.ENDM

; Выбор N из M вариантов
; параметр N = сколько выбрать, M = всего вариантов
.MACRO	.SELNM	N, M
	MOV	#WTSELT, R1
	CALL	PRINT
	MOV	#<N>, R0
	MOV	#<M>, R1
	CALL	SELNM
.ENDM

; Показать вставку на экране
; параметр N = номер вставки;
; параметры X,Y = координаты на экране
.MACRO	.SHEXT	N, X, Y
	MOV	#N, R0			; номер вставки
	MOV	#<Y*400+X>, R1		; X/Y
	CALL	PPREX			; показать вставку
.ENDM

; Скопировать фрагмент с теневого экрана на основной
; параметры X,Y = координаты на экране
; параметры W,H = размеры фрагмента
.MACRO	.FRAGM	X, Y, W, H
	MOV	#<SSCR80+<Y*8.*80.>+X>, R0	; откуда
	MOV	#<SCRE80+<Y*8.*80.>+X>, R1	; куда
	MOV	#<H*400+W>, R2			; W/H
	CALL	PPREX2			; скопировать фрагмент
.ENDM

; Ожидание по таймеру
; параметр T = количество тиков 50 Гц которые нужно ждать
.MACRO	.WTIME	T
	MOV	#<T>, R0
	CALL	WTTIME
.ENDM

; Анимация: вывод двух вставок и паузы между
; параметры N,M = номера вставок
; параметры X,Y = координаты на экране
; параметр T = величина задержки
.MACRO	.ANIM	N, M, X, Y, T
	MOV	#<N>, R0
	MOV	#<M>, R1
	MOV	#<<Y>*400+<X>>, R2
	MOV	#<T>, R3
	CALL	ANIMAT
.ENDM

; Переход на другой уровень; N = 1..7
.MACRO	.LEVEL	N
	MOV	#GAMESC, R1
	CALL	PRINT			; Очистить экран
	CALL	PAUSE
	MOV	#<LEVELS+<<N-1>*12.>>, R0
	JMP	LOALEV			; К загрузке уровня
.ENDM

;------------------------------------------------------------------------------

	. = 010000
	. = <.+511.>&177000		; Выравниваем по границе блока
; Место начала кода уровня
LBEGIN::
.INCLUDE /LEVEL.MAC/
LEND::
ESTRAT = LBEGIN+2

;------------------------------------------------------------------------------
	.END	START
